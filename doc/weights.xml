#############################################################################
##
#W  weights.xml
#Y  Copyright (C) 2014-19                               Raiyan Chowdhury
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##


<#GAPDoc Label="EdgeWeights">
    <ManSection>
    <Attr Name="EdgeWeights" Arg="digraph"/>
    <Oper Name="EdgeWeightsMutableCopy" Arg="digraph"/>
    <Returns>A list of lists of integers, floats or rationals.</Returns>
    <Description>
     <C>EdgeWeights</C> returns the list of lists of edge weights of
    each edge of the digraph <A>digraph</A>.

    More specifically, a value <C>j</C> appears in <C>weights[i]</C> each time
    there exists the edge <C>[i, j]</C> in <A>digraph</A>. <P/>

    The function <C>EdgeWeights</C> returns an immutable list of
    lists, whereas the function <C>EdgeWeightsMutableCopy</C> returns a copy
    of <C>EdgeWeights</C> which is a mutable list of mutable lists. <P/>
    <Example><![CDATA[
gap> gr := EdgeWeightedDigraph([[2],[3],[1]], [[5],[10],[15]]);                                 
<immutable digraph with 3 vertices, 3 edges>
gap> EdgeWeights(gr);
[ [ 5 ], [ 10 ], [ 15 ] ]
gap> a := EdgeWeightsMutableCopy(gr);
[ [ 5 ], [ 10 ], [ 15 ] ]
gap> a[1][1] := 100;
100
gap> a;                              
[ [ 100 ], [ 10 ], [ 15 ] ]
gap> b := EdgeWeights(gr);
[ [ 5 ], [ 10 ], [ 15 ] ]
gap> b[1][1] := 534;
Error, List Assignment: <list> must be a mutable list
not in any function at *stdin*:39
type 'quit;' to quit to outer loop    
    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>


<#GAPDoc Label="EdgeWeightedDigraph">
    <ManSection>
    <Func Name="EdgeWeightedDigraph" Arg="digraph, weights"/>
    <Returns>A digraph or <K>fail</K></Returns>
    <Description>
        <A>digraph</A> may be a Digraph or a list of lists of integers, floats or rationals.

        <A>weights</A> must be a list of lists of integers, floats or rationals of an equal size and shape to <A>digraph</A>, otherwise
        it will fail.


        This will create a EdgeWeightedDigraph and set the EdgeWeights to <A>weights</A>.
        
        See <Ref Attr="EdgeWeights"/>.
    <Example><![CDATA[
gap> g := EdgeWeightedDigraph(Digraph([[2, 3], [1], [2, 3]]), [[5,10],[15],[20,25]]);        
<immutable digraph with 3 vertices, 5 edges>
gap> g := EdgeWeightedDigraph([[2, 3], [1], [2, 3]], [[5,10],[15],[20,25]]);
<immutable digraph with 3 vertices, 5 edges>
    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphEdgeWeightedMinimumSpanningTree">
    <ManSection>
    <Attr Name="DigraphEdgeWeightedMinimumSpanningTree" Arg="digraph"/>
    <Returns>A record.</Returns>
    <Description>
        This function returns the record with 2 components <C>total</C> and <C>mst</C>. 
        The first component <C>total</C> represents the sum of the edge weights of the digraph that is returns. 
        The second component <C>mst</C> is the edge weighted digraph representation of the mst.
        <P/>

        See <Ref Attr="EdgeWeights" Func="EdgeWeightedDigraph"/>.
    <Example><![CDATA[
gap> g := EdgeWeightedDigraph([[2],[1],[1,2]], [[12],[5],[6,9]]);
<immutable digraph with 3 vertices, 4 edges>
gap> DigraphEdgeWeightedMinimumSpanningTree(g); 
rec( mst := <immutable digraph with 3 vertices, 2 edges>, total := 11 )
    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphEdgeWeightedShortestPathsFromVertex">
    <ManSection>
    <Oper Name="DigraphEdgeWeightedShortestPathsFromVertex" Arg="digraph, start"/>
    <Returns>A record.</Returns>
    <Description>
        This operation, given a edge weighted <A>digraph</A> and a <A>start</A> vertex will return a record
        with 3 components. The first component is the distances which is a list of shortest distance 
        to each node from the <A>start</A> node. The distance from the start node to itself is always 0.
        The second component is the edges, which signifies which edge was taken to get to that vertex from the parent of that node
        which is the third component; a list of vertices which are the parents of that vertex. Using both these components
        together, you can find the shortest edge weighted path to all other vertices from a starting vertex. In 
        In cases, where a path doesn't exist and therefore there are no distances, edges or parents, the lists will
        contain a fail. 
        <P/>

        This operation can handle negative edge weights BUT it will error if a negative cycle exists.
        <P/>

        See <Ref Attr="EdgeWeights" Func="EdgeWeightedDigraph"/>.
    <Example><![CDATA[
gap> g := EdgeWeightedDigraph([[2,3],[4],[4],[]],[[5,1],[6],[11],[]]);
<immutable digraph with 4 vertices, 4 edges>
gap> DigraphEdgeWeightedShortestPathsFromVertex(g,1);
rec( distances := [ 0, 5, 1, 11 ], edges := [ fail, 1, 2, 1 ], parents := [ fail, 1, 1, 2 ] )
gap> g := EdgeWeightedDigraph([[2],[3],[1]],[[1],[-2],[-3]]);  
<immutable digraph with 3 vertices, 3 edges>
gap> DigraphEdgeWeightedShortestPathsFromVertex(ncg,1);      
rec( distances := [ 0, 1, 3 ], edges := [ fail, 1, 1 ], parents := [ fail, 1, 2 ] )
gap> ncg := EdgeWeightedDigraph([[2],[3],[1]],[[-1],[-2],[-3]]);
<immutable digraph with 3 vertices, 3 edges>
gap> DigraphEdgeWeightedShortestPathsFromVertex(ncg,1); 
Error, negative cycle exists, at /home/mrc7/.gap/pkg/digraphs-1.6.1/gap/weights.gi:373 called from
DIGRAPHS_Edge_Weighted_Bellman_Ford( digraph, source 
 ) at /home/mrc7/.gap/pkg/digraphs-1.6.1/gap/weights.gi:393 called from
<function "DigraphEdgeWeightedShortestPathsFromVertex for an edge weighted digraph">( <arguments> )
 called from read-eval loop at *stdin*:6
type 'quit;' to quit to outer loop
    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphEdgeWeightedShortestPaths">
    <ManSection>
    <Attr Name="DigraphEdgeWeightedShortestPaths" Arg="digraph"/>
    <Returns>A list of lists of integers, floats or rationals.</Returns>
    <Description>
        Given an edge weighted <A>digraph</A>, this returns a list of lists of the shortest distance from one vertex to every other vertex. 
        If no paths exist, then fail will be returned in the 2D list. This will return an incorrect answer if negative cycles exists.

        See <Ref Attr="EdgeWeights" Func="EdgeWeightedDigraph"/>.
    <Example><![CDATA[
gap> g := EdgeWeightedDigraph([[2],[3],[1]],[[1],[2],[3]]);
<immutable digraph with 3 vertices, 3 edges>
gap> DigraphEdgeWeightedShortestPaths(g);
[ [ 0, 1, 3 ], [ 5, 0, 2 ], [ 3, 4, 0 ] ]
    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphMaximumFlow">
    <ManSection>
    <Attr Name="DigraphMaximumFlow" Arg="digraph, start, destination"/>
    <Returns>A record.</Returns>
    <Description>
        Given an edge weighted <A>digraph</A>, this returns a record with 3 components. 
        The first component is the flow inbound into vertex v which is a list of lists. 
        If there are multiple edges, the algorithm will fill up the edges sequentially so 
        if there are 3 edges outbound from u to v with capacities, 5,10,15 and there is a flow of 15, it will fill the first two edges 5 and 10. 
        If there is a flow of 9, then the flow will contain a list with flows 5 and 4. <P/>

        This can be coupled with the second component which is a list of list of the vertices that each flow comes from. Using this, 
        allows the path of the flow and the flow to be obtained using the first component. <P/>

        The third and last component is the maximum flow value which is the highest flow that we can obtain from start to destination. <P/>

        See <Ref Attr="EdgeWeights" Func="EdgeWeightedDigraph"/>.
    <Example><![CDATA[

    ]]>
    </Example>
    </Description>
    </ManSection>
<#/GAPDoc>